module Melody

    using Random

    export MelodySampleSpace, makeMelodySampleSpace
    export getZero, getMelodyIndex, getMelodyFromIndex, isCircular
    export generateSample

    """
    MelodySampleSpace defines criteria for generating a melody,
        i.e. a sequence of music notes subject to constraints such 
        as the length (n) of the sequence of notes and, more critical, 
        the set of A-dmitted V-ariations (i.e. increase or decrease) of 
        the  S-ound P-itch (AVSP) of a note W-ith R-espect to the pitch 
        of the P-receding N-ote  (WRTPN), in units of 1 semi-tone. 
        This set is given as an array (AVSPWRTPN) of Int8 values 
        Typical choices for AVSPWRTPN could be:
            A)  {-5,-4,-3,-2,-1,0,1,2,3,4,5} or
            B)  {-5,-4,-3,-2,-1,  1,2,3,4,5}
        where choice B) restrict melodies to those where there can
        NOT be two or more consecutive instances of the same note. 
        Once AVSPWRTPN is given, a sequence of (n-1) of its values, 
        together with the note (pitch value) at a single place of the
        corresponding sequence, defines an entire melody of length n. 
    """
    struct MelodySampleSpace
        
        # The number of  i n t e r v a l s  (AVSPWRTPN) in each melody.
        # A melody in this space therefore contains  (n + 1)   n o t e s 
        n::UInt8
    	
        # Within the whole sequence of notes that make a melody generated by this SW,
        # each number in the AVSPWRTPN array represents one element of the set of 
        # A-dmitted V-ariations (i.e. increase or decrease) of the  S-ound P-itch (AVSP)
        # of a note W-ith R-espect to the pitch of the P-receding N-ote  (WRTPN), in 
        # units of  1  semi-tone. We also use the word 'intervals' to refer to these.
        # Being AVSPWRTPN the array representation of a set, the
        # same value MUST NOT appear more than ONCE in this array!
        AVSPWRTPN::Vector{Int8}

        # Number of distinct melodies satisfying the above two criteria
        # This number equals  length(AVSPWRTPN)^n 
        # 
        # be compared with the largest value of a UInt64 integer: (2^64 -1)
        spaceSize::UInt64

        # (*) For the purposes of this software, any two melodies are considered the SAME melody
        #     if one can be obtained from the other by applying a uniform translation of pitch!
        #     Therefore, the number of distinct melodies is length(AVSPWRTPN)^n

    end # struct

    """
    This builder of a MelodySampleSpace (MSS) assumes the AVSPWRTPN 
    vector to be the sequence of all integers from -m to +m with the  
    Zero optionally excluded by specifying 'allowZero = false' 
    - n::UInt8   is the length of the melody, i.e. the number of notes in it.
    - m::UInt8   is a positive integer, and we consider the set of integers in [-m, +m] 
    - allowZero::Bool   if false, we exclude zero from the above interval [-m, +m]
    """
    function makeMelodySampleSpace(n::UInt8, m::UInt8; allowZero::Bool = true) 
        if allowZero
            avspwrtpn = Int8[-Int8(m):1:Int8(m);]
            spaceSize = UInt64((2m+1)^n)
        else
            avspwrtpn = zeros(Int8, 2*m)
            avspwrtpn[  1: m] = Int8[-Int8(m):1:Int8(-1);]
            avspwrtpn[m+1:2m] = Int8[ Int8(1):1:Int8( m);]
            spaceSize = UInt64((2m)^n)
        end
        
        MelodySampleSpace(n, avspwrtpn, spaceSize)
        
    end # function

    """
    Return the UInt64 integer value in the interval [0 : mss.spaceSize - 1] 
    uniquely determined by the input Int8[] array of mss.n elements 
    Note 1: The MIN value that a melody index can assume is 0
    Note 2: The MAX value that a melody index can assume is (mss.spaceSize - 1)  ! Beware of the '-1' !
    Note 3: All 'intervals' in the melody with the MIN index equal mss.AVSPWRTPN[1]
    Note 4: All 'intervals' in the melody with the MAX index equal mss.AVSPWRTPN[L] (L AVSPWRTPN's length) 
    """
    function getMelodyIndex(mss::MelodySampleSpace, melody::Vector{Int8})::UInt64
        # Validate the melody input argument's length
        @assert (length(melody) == mss.n)  ArgumentError("melody's length ($(length(melody)) != mss.n ($(mss.n))")
        
        # Validate each one of melody's elements against mss.AVSPWRTPN
        AVSPWRTPN_length = length(mss.AVSPWRTPN)
        avsp_matching_element_index = zeros(Int8, mss.n)
        for k in 1:Int(mss.n)
            avsp_k = melody[k]
            k_match = false
            for j in 1:AVSPWRTPN_length
                if (avsp_k == mss.AVSPWRTPN[j])
                    avsp_matching_element_index[k] = j
                    k_match = true; break
                end
            end
            @assert k_match ArgumentError("The $(k)-th melody element ($avsp_k) does NOT match any element in mss.AVSPWRTPN")
        end

        # Compute the melody index 
        awspCardinality = length(mss.AVSPWRTPN)     # Cardinality of AVSPWRTPN (as a set of unique elements)
        pow = awspCardinality^(Int(mss.n) - 1)      # Max needed pow of AVSPWRTPN's (set) cardinality
        melody_index = Int64(0)                     # We take 0 to be the lowest possible melody index 

        for k in 1:Int(mss.n)
            j = avsp_matching_element_index[k]
            melody_index += (j-1)*pow
            pow = div(pow, awspCardinality)         # Beware! 'pow /= awspCardinality' would produce a FLOAT64
        end

        return melody_index
    end

    """
    Return the melody as an Int8[] array of AVSP from a UInt64 integer value in
    the interval [0 : mss.spaceSize - 1], to be interpreted as the melody index. 
    Note 1: The MIN value that a melody index can assume is 0
    Note 2: The MAX value that a melody index can assume is (mss.spaceSize - 1)  ! Beware of the '-1' !
    Note 3: All 'intervals' in the melody with the MIN index equal mss.AVSPWRTPN[1]
    Note 4: All 'intervals' in the melody with the MAX index equal mss.AVSPWRTPN[L] (L AVSPWRTPN's length) 
    """
    function getMelodyFromIndex(mss::MelodySampleSpace, index::UInt64)::Vector{Int8}
        # Validate input arguments
        @assert (index >= 0)             ArgumentError("index ($index) cannot be lower than 0")
        @assert (index < mss.spaceSize)  ArgumentError("index ($index) must be lower than $(mss.spaceSize)")
        
        # Derive a Vector{Int8} array with mss.n elements, each one also being an element of mss.AVSPWRTPN.
        avspCardinality = UInt64(length(mss.AVSPWRTPN)) # Cardinality of AVSPWRTPN (as a set of unique elements)
        pow    = UInt64(avspCardinality)^(Int(mss.n))   # AVSPWRTPN's cardinality power of melodies AVSP (**) 

        melody = zeros(Int8, mss.n)                     # Initialize melody with  mss.n  zeros
        windex = index                                  # Avoid messing with the input argument
        for k in 1:Int(mss.n)
            pow  = UInt64(pow / avspCardinality)        # Cardinality power associated to the k-th AVSP element 
            println("k: $k, melody[$k]: $(melody[k]), type of pow: $(typeof(pow)),  pow(k): $(pow)" )
            divisor = div(windex, pow)                  # Divisor MUST be in the range  0:length(mss.AVSPWRTPN)-1
            println("k=$k, windex=$windex, divisor=$(Int8(divisor)), pow = $(Int(pow))")
            melody[k] = mss.AVSPWRTPN[Int8(divisor)+1]  # Julia array indexing is 1-based, yet divisor can be zero!
            windex -= Int(pow * divisor)
            # pow  = UInt64(pow / avspCardinality)      # Moved to the loop's beginning, as explained below (**)
        end

        return melody
        # (**) Initializing UInt64(avspCardinality)^(Int(mss.n)), although the max power of avspCardinality that 
        # is required for representing all possible melodies is avspCardinality^(Int(mss.n) - 1). Our choice 
        # here is done just so that the pow's value can be made available with the 1ST instruction of the 
        # following for-loop over k, rather than with the LAST one (as it would otherwise be necessary).
    end

    """
	I M P O R T A N T   O B S E R V A T I O N  on  C I R C U L A R   melodies
	The sum of the <n> AVSP's in a particular melody may be zero. 
	We refer to sequences with this property as   C I R C U L A R . 
	The following scheme (where '|' is a note and 'a,b,c...' are AVSP's) should explain why 
	
	0 1 2 3 . . . . . . . . . . . . . . n 0 1 2 3 . . . . . . . . . . . . . . . . n 0	:  n+1 NOTES per melody
    |a|b|c|_|_|_|_|_|_|_|_|_|_|_|_|_|x|y|z|a|b|c|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|x|y|z|
	 1 2 3 . . . . . . . . . . . . . . . n 1 2 3 . . . . . . . . . . . . . . . . . n    :  n   AVSPs per melody
	
	Let the sum a+b+c+ ... + x+y+z be zero. But a,b,c,... represent intervals (in pitch)
	between two consecutive sounds. Thus |a| is the interval between sounds 1 and 2, etc.
	Iff the SUM a+b+c+...+x+y+z = 0 we assert that the k-th and the (k+n)-th  notes
	have the same sound pitch, i.e. they are the S A M E  note.
    When this happens we say that a particular melody (sequence of AVSPs)  is   C I R C U L A R
	 
	This method returns true  IFF a melody with the given index is  C I R C U L A R 
	 
	"""
    function isCircular(melodyIndex::UInt64, mss::MelodySampleSpace)::Bool
        # Remind: there is one AVSP less in a melody than there are notes

        avsp = getMelodyFromIndex(melodyIndex, mss)
        sum = 0
        for k in 1:mss.n    
            sum += avsp[k]
        end

        return (sum == 0)

    end

    """
    Generate random melodies to form a sample of the specified size
    """
    function generateSample(mss::MelodySampleSpace, sampleSize::UInt64; 
                            seed::Int = 123, 
                            range::UnitRange{UInt64} = UInt64(0):UInt64(mss.spaceSize - 1),
                            xoshiro::Bool = true)::Vector{UInt64}

        rng = xoshiro ? Xoshiro(seed) : MersenneTwister(seed)
        
        sample = rand(rng, range, sampleSize)
    end

end # module