module Melody

    export MelodySampleSpace, BuildMelodySampleSpace

    """
    MelodySampleSpace defines criteria for generating a melody,
        i.e. a sequence of music notes subject to constraints such 
        as the length (n) of the sequence and, more critical, the set
        of A-dmitted V-ariations (i.e. increase or decrease) of the 
        S-ound P-itch of a note W-ith R-espect to the pitch of the 
        P-receding N-ote (in units of 1 semi-tone). 
        This set is given as an array (AVSPWRTPN) of Int8 values 
        Typical choices for AVSPWRTPN could be:
            A)  {-5,-4,-3,-2,-1,0,1,2,3,4,5} or
            B)  {-5,-4,-3,-2,-1,  1,2,3,4,5}
        where choice B) restrict melodies to those where there can
        NOT be two or more consecutive instances of the same note. 
        Once AVSPWRTPN is given, a sequence of (n-1) of its values, 
        together with the note (pitch value) at a single place of the
        corresponding sequence, defines an entire melody of length n. 
    """
    struct MelodySampleSpace
        
        # Length (the number of notes) of a melody within the space
        n::Int8
    	
        # Within the whole sequence of notes that make a melody generated by this software,
        # each number in the AVSPWRTPN array represents one of the only A-dmitted V-ariations  
  	    # of S-ound P-itch (in multiples of a semitone) W-ith R-espect to the P-receding N-ote.
        # The same value MUST NOT appear more than ONCE in AVSPWRTPN!
        AVSPWRTPN::Vector{Int8}

        # Number of distinct melodies(*) satisfying the above two criteria
        # This number is computed as  length(AVSPWRTPN)^(n-1), a number to be 
        # compared with the largest value of a UInt64 value (2^64 -1)
        numberOfDistinctMelodies::UInt64

        # (*) For the purposes of this software, any two melodies are considered the SAME melody
        #     if one can be obtained from the other by applying a uniform translation of pitch!   

    end # struct

    """
    This builder of a MelodySampleSpace (MSS) assumes the AVSPWRTPN 
    vector to be the sequence of all integers from -m to +m with the  
    Zero optionally excluded by specifying 'allowZero = false' 
    - n::Int    is the length of the melody, i.e. the number of notes in it.
    - m::Int    is a positive integer, and we consider the set of integers in [-m, +m] 
    - allowZero::Bool   if false, we exclude zero from the above interval [-m, +m]
    """
    function BuildMelodySampleSpace(n::Int, m::UInt; allowZero::Bool = true) 
        if allowZero
            avspwrtpn = Int8[-Int8(m):1:Int8(m);]
            spacesize = (2m+1)^(n-1)
        else
                avspwrtpn = zeros(Int8, 2*m)
                avspwrtpn[  1: m] = Int8[-Int8(m):1:Int8(-1);]
                avspwrtpn[m+1:2m] = Int8[ Int8(1):1:Int8( m);]
                spacesize = (2m)^(n-1)
        end
        MelodySampleSpace(Int8(n), avspwrtpn, UInt64(spacesize))
    end # function



end # module