module Melody

    using Dictionaries
    using Random

    export MelodySampleSpace, makeMelodySampleSpace
    export getZero, getMelodyIndex, getMelodyFromIndex
    export getMelodyOffset, getMelodyAttributes
    export generateSample, allMelodies
    export melodyClassesRepresentative

    """
    MelodySampleSpace defines criteria for generating a melody,
        i.e. a sequence of music notes subject to constraints such 
        as the length (n) of the sequence of notes and, more critical, 
        the set of A-dmitted V-ariations (i.e. increase or decrease) of 
        the  S-ound P-itch (AVSP) of a note W-ith R-espect to the pitch 
        of the P-receding N-ote  (WRTPN), in units of 1 semi-tone. 
        This set is given as an array (AVSPWRTPN) of Int8 values 
        Typical choices for AVSPWRTPN could be:
            A)  {-5,-4,-3,-2,-1,0,1,2,3,4,5} or
            B)  {-5,-4,-3,-2,-1,  1,2,3,4,5}
        where choice B) restrict melodies to those where there can
        NOT be two or more consecutive instances of the same note. 
        Once AVSPWRTPN is given, a sequence of (n-1) of its values, 
        together with the note (pitch value) at a single place of the
        corresponding sequence, defines an entire melody of length n. 
    """
    struct MelodySampleSpace
        
        # The number of  i n t e r v a l s  (AVSPWRTPN) in each melody.
        # A melody in this space therefore contains  (n + 1)   n o t e s 
        n::UInt8
    	
        # Within the whole sequence of notes that make a melody generated by this SW,
        # each number in the AVSPWRTPN array represents one element of the set of 
        # A-dmitted V-ariations (i.e. increase or decrease) of the  S-ound P-itch (AVSP)
        # of a note W-ith R-espect to the pitch of the P-receding N-ote  (WRTPN), in 
        # units of  1  semi-tone. We also use the word 'intervals' to refer to these.
        # Being AVSPWRTPN the array representation of a set, the
        # same value MUST NOT appear more than ONCE in this array!
        AVSPWRTPN::Vector{Int8}

        # Number of distinct melodies satisfying the above two criteria
        # This number equals  length(AVSPWRTPN)^n 
        # 
        # be compared with the largest value of a UInt64 integer: (2^64 -1)
        spaceSize::UInt64

        # (*) For the purposes of this software, any two melodies are considered the SAME melody
        #     if one can be obtained from the other by applying a uniform translation of pitch!
        #     Therefore, the number of distinct melodies is length(AVSPWRTPN)^n

    end # struct

    """
    This builder of a MelodySampleSpace (MSS) assumes the AVSPWRTPN 
    vector to be the sequence of all integers from -m to +m with the  
    Zero optionally excluded by specifying 'allowZero = false' 
    - n::UInt8   is the length of the melody, i.e. the number of notes in it.
    - m::UInt8   is a positive integer, and we consider the set of integers in [-m, +m] 
    - allowZero::Bool   if false, we exclude zero from the above interval [-m, +m]
    """
    function makeMelodySampleSpace(n::UInt8, m::UInt8; allowZero::Bool = true) 
        if allowZero
            avspwrtpn = Int8[-Int8(m):1:Int8(m);]
            spaceSize = UInt64((2m+1)^n)
        else
            avspwrtpn = zeros(Int8, 2*m)
            avspwrtpn[  1: m] = Int8[-Int8(m):1:Int8(-1);]
            avspwrtpn[m+1:2m] = Int8[ Int8(1):1:Int8( m);]
            spaceSize = UInt64((2m)^n)
        end
        
        MelodySampleSpace(n, avspwrtpn, spaceSize)
        
    end # function

    """
    Return the UInt64 integer value in the interval [0 : mss.spaceSize - 1] 
    uniquely determined by the input Int8[] array of mss.n elements 
    Note 1: The MIN value that a melody index can assume is 0
    Note 2: The MAX value that a melody index can assume is (mss.spaceSize - 1)  ! Beware of the '-1' !
    Note 3: All 'intervals' in the melody with the MIN index equal mss.AVSPWRTPN[1]
    Note 4: All 'intervals' in the melody with the MAX index equal mss.AVSPWRTPN[L] (L AVSPWRTPN's length) 
    """
    function getMelodyIndex(mss::MelodySampleSpace, melody::Vector{Int8})::UInt64
        # Validate the melody input argument's length
        @assert (length(melody) == mss.n)  ArgumentError("melody's length ($(length(melody)) != mss.n ($(mss.n))")
        
        # Validate each one of melody's elements against mss.AVSPWRTPN
        AVSPWRTPN_length = length(mss.AVSPWRTPN)
        avsp_matching_element_index = zeros(Int8, mss.n)
        for k in 1:Int(mss.n)
            avsp_k = melody[k]
            k_match = false
            for j in 1:AVSPWRTPN_length
                if (avsp_k == mss.AVSPWRTPN[j])
                    avsp_matching_element_index[k] = j
                    k_match = true; break
                end
            end
            @assert k_match ArgumentError("The $(k)-th melody element ($avsp_k) does NOT match any element in mss.AVSPWRTPN")
        end

        # Compute the melody index 
        awspCardinality = length(mss.AVSPWRTPN)     # Cardinality of AVSPWRTPN (as a set of unique elements)
        pow = awspCardinality^(Int(mss.n) - 1)      # Max needed pow of AVSPWRTPN's (set) cardinality
        melody_index = Int64(0)                     # We take 0 to be the lowest possible melody index 

        for k in 1:Int(mss.n)
            j = avsp_matching_element_index[k]
            melody_index += (j-1)*pow
            pow = div(pow, awspCardinality)         # Beware! 'pow /= awspCardinality' would produce a FLOAT64
        end

        return melody_index
    end

    """
    Return the melody as an Int8[] array of AVSP from a UInt64 integer value in
    the interval [0 : mss.spaceSize - 1], to be interpreted as the melody index. 
    Note 1: The MIN value that a melody index can assume is 0
    Note 2: The MAX value that a melody index can assume is (mss.spaceSize - 1)  ! Beware of the '-1' !
    Note 3: All 'intervals' in the melody with the MIN index equal mss.AVSPWRTPN[1]
    Note 4: All 'intervals' in the melody with the MAX index equal mss.AVSPWRTPN[L] (L AVSPWRTPN's length) 
    """
    function getMelodyFromIndex(mss::MelodySampleSpace, index::UInt64)::Vector{Int8}
        # Validate input arguments
        @assert (index >= 0)             ArgumentError("index ($index) cannot be lower than 0")
        @assert (index < mss.spaceSize)  ArgumentError("index ($index) must be lower than $(mss.spaceSize)")
        
        # Derive a Vector{Int8} array with mss.n elements, each one also being an element of mss.AVSPWRTPN.
        avspCardinality = UInt64(length(mss.AVSPWRTPN)) # Cardinality of AVSPWRTPN (as a set of unique elements)
        pow    = UInt64(avspCardinality)^(Int(mss.n))   # AVSPWRTPN's cardinality power of melodies AVSP (**) 

        melody = zeros(Int8, mss.n)                     # Initialize melody with  mss.n  zeros
        windex = index                                  # Avoid messing with the input argument
        for k in 1:Int(mss.n)
            pow  = UInt64(pow / avspCardinality)        # Cardinality power associated to the k-th AVSP element 
            # println("k: $k, melody[$k]: $(melody[k]), type of pow: $(typeof(pow)),  pow(k): $(pow)" )
            divisor = div(windex, pow)                  # Divisor MUST be in the range  0:length(mss.AVSPWRTPN)-1
            # println("k=$k, windex=$windex, divisor=$(Int8(divisor)), pow = $(Int(pow))")
            melody[k] = mss.AVSPWRTPN[Int8(divisor)+1]  # Julia array indexing is 1-based, yet divisor can be zero!
            windex -= Int(pow * divisor)
            # pow  = UInt64(pow / avspCardinality)      # Moved to the loop's beginning, as explained below (**)
        end

        return melody
        # (**) Initializing UInt64(avspCardinality)^(Int(mss.n)), although the max power of avspCardinality that 
        # is required for representing all possible melodies is avspCardinality^(Int(mss.n) - 1). Our choice 
        # here is done just so that the pow's value can be made available with the 1ST instruction of the 
        # following for-loop over k, rather than with the LAST one (as it would otherwise be necessary).
    end

    """
	We call  melody  O F F S E T  the sum of the <n> AVSP's in a melody. 
	When this sum is zero, we refer to the corresponding melody as being C L O S E D. 
	The following scheme (where '|' is a note and 'a,b,c...' are AVSP's) should explain why 
	
	0 1 2 3 . . . . . . . . . . . . . . n 0 1 2 3 . . . . . . . . . . . . . . . . n 0	:  n+1 NOTES per melody
    |a|b|c|_|_|_|_|_|_|_|_|_|_|_|_|_|x|y|z|a|b|c|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|x|y|z|
	 1 2 3 . . . . . . . . . . . . . . . n 1 2 3 . . . . . . . . . . . . . . . . . n    :  n   AVSPs per melody
	
	a,b,c,... represent intervals (in pitch) between two consecutive sounds. 
    Thus |a| is the interval between sounds 1 and 2, etc.
	The SUM a+b+c+...+x+y+z defines the  O F F S E T  between k-th and the (k+n)-th note.
	"""
    function getMelodyOffset(melodyIndex::UInt64, mss::MelodySampleSpace)::Int
        avsp = getMelodyFromIndex(melodyIndex, mss)
        off = 0
        for k in 1:mss.n    
            off += avsp[k]
        end
        return off
    end

    """
	O B S E R V A T I O N S   on   C L O S E D   and   C I R C U L A R   melodies
	The sum of the <n> AVSP's in a particular melody may be zero. 
	We refer to sequences with this property as   C L O S E D. 

    The sum of the <n> AVSP's of a particular melody, within a given melody sample space (mss), 
    may or may NOT be equal to one of the  <n> AVSP's associated with that mss. IFF it is, 
    then we qualify the melody as  C I R C U L A R 

	The following scheme (where '|' is a note and 'a,b,c...' are AVSP's) should explain why 
	
	0 1 2 3 . . . . . . . . . . . . . . n 0 1 2 3 . . . . . . . . . . . . . . . . n 0	:  n+1 NOTES per melody
    |a|b|c|_|_|_|_|_|_|_|_|_|_|_|_|_|x|y|z|a|b|c|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|x|y|z|
	 1 2 3 . . . . . . . . . . . . . . . n 1 2 3 . . . . . . . . . . . . . . . . . n    :  n   AVSPs per melody
	
	Let the sum a+b+c+ ... + x+y+z be zero. But a,b,c,... represent intervals (in pitch)
	between two consecutive sounds. Thus |a| is the interval between sounds 1 and 2, etc.
	Iff the SUM a+b+c+...+x+y+z = 0 we assert that the k-th and the (k+n)-th  notes
	have the same sound pitch, i.e. they are the S A M E  note.
    When this happens we say that a particular melody (sequence of AVSPs)  is   C L O S E D
	When the above SUM equals one of the values in mss.AVSPWRTPN, we say it is  C I R C U L A R 
	"""
    function getMelodyAttributes(melodyIndex::UInt64, mss::MelodySampleSpace)::Tuple{Bool, Bool}
        off = getMelodyOffset(melodyIndex, mss)
        closed = (off == 0)
        circular = (off in mss.AVSPWRTPN)

        return (closed, circular)
    end
    
    
    """
    This method of the function getMelodyAttribute works directly with the melody's AVSP
    """
    function getMelodyAttributes(melody::Vector{Int8}, mss::MelodySampleSpace)::Tuple{Bool, Bool}
        off = sum(melody)
        closed = (off == 0)
        circular = (off in mss.AVSPWRTPN)

        return (closed, circular)
    end


    """
    Generate random sample of melodies of the specified size
    """
    function generateSample(mss::MelodySampleSpace, sampleSize::UInt64; 
                            seed::Int = 123, 
                            range::UnitRange{UInt64} = UInt64(0):UInt64(mss.spaceSize - 1),
                            xoshiro::Bool = true)::Vector{UInt64}

        rng = xoshiro ? Xoshiro(seed) : MersenneTwister(seed)
        
        sample = rand(rng, range, sampleSize)
    end

    """
    Build the matrix (Array{Int8, 2}), each of whose <m>^<n> columns contains the representation 
    of a melody by the corresponding sequence of <n> Int8 values, each taken from mss.AVSPWRTPN
    The matrix columns are ordered so that the k-th column stores the melody of index k

    Build the vector of tuples (Vector{Tuple{Bool, Bool}}}), each one of whose elements contains 
    two Boolean attributes of the corresponding melody: 'isClosed' and  'isCircular'  

    The function returns the matrix and the vector as elements of a tuple.
    """
    function allMelodies(mss::MelodySampleSpace; ramLimitGb = 33)::Tuple{Matrix{Int8}, Vector{Tuple{Bool, Bool}}}

        # 0. Extract info from mss argument (melody sample space)
        n = mss.n

        # 1. Check there is enough RAM available for the output matrix, as per declared limit
        ramNeededGb = (mss.spaceSize * n) / 1024^3
        println("RAM needed (Gb): $ramNeededGb")
        @assert(ramNeededGb <= ramLimitGb, "RAM needed (Gb): $ramNeededGb, RAM limit: ramLimitGb")

        t1 = time()
        matrix = zeros(Int8, n, mss.spaceSize)
        t2 = time()

        println("Matrix memory allocation alone required $(t2-t1) seconds")

        # 2. Store a distinct melody (AVSPWRTPN sequence) in each column of matrix

        for melody_index in UInt64(0):UInt64(mss.spaceSize - 1)
            matrix[:, melody_index+1] = getMelodyFromIndex(mss, melody_index) 
        end
        t3 = time()
        println("Generating and storing columns required $(t3-t2) seconds")

        # 3. Preallocate space to hold a Tuple{Bool, Bool} for each melody
        vector = Vector{Tuple{Bool, Bool}}(undef, mss.spaceSize) 

        # 4. Evaluate and store the attributes (isClosed, isCircular) for each melody
        nofClosed = 0
        nofCircular = 0
        nofBoth = 0
        for melody_index in UInt64(0):UInt64(mss.spaceSize - 1)
            melody = matrix[:, melody_index+1]      # retrieve the melody from matrix column
            attributes = getMelodyAttributes(melody, mss)

            # Take statistics:
            if attributes[1] nofClosed += 1; end
            if attributes[2] nofCircular += 1; end
            if attributes[1] && attributes[2] nofBoth += 1; end

            vector[melody_index+1] = attributes
        end
        t4 = time()

        println("closed: $nofClosed, circular: $nofCircular, both: $nofBoth")
        println("Generating and storing attributes required $(t4-t3) seconds")
        
        # 5. Return the matrix and the vector
        (matrix, vector)
    end


    """
    For any   C I R C U L A R    melody it is possible(*) to generate a
    number of other melodies by 'rotating' the sequence of AVSP's, clock-wise 
    (or counter-clock-wise), in unit steps. 

    INPUTs: mss    :  the melody sample space  
                      Assume k âˆˆ 1:mss.spaceSize, i.e. 1:length(mss.AVSPWRTPN)^(mss.n) 
            matrix :  k-th column of which contains the melody of index (k-1) 
            vector :  k-th element of which is tuple (isClosed::Bool, isCircular::Bool):
                      attributes also associated to the melody of index (k-1) 

    OUTPUT: This function returns a Dictionary{UInt64, UInt64} where the Key is a valid
            melody index ( number in the unit range UInt64(0):UInt64(mss.spaceSize - 1) ) 
            The corresponding value is the minimum UInt64 value within the set of indices 
            obtained by 'rotating' melody elements in matrix[:, k]. That set includes the 
            input melody_index as well as indices of any 'rotated' melody.

        (*) In principle, the mapping could also be applied to a NON CIRCULAR melody. 
            In that case, however, one or more 'rotated' melodies woud NOT satisfy the
            requirement of belonging to the melody sample space ( mss input argument ), 
            as one or more melody elements would NOT be an element of mss.AVSPWRTPN !
    """
    function melodyClassesRepresentative(mss::MelodySampleSpace, matrix::Matrix{Int8}, vector::Vector{Tuple{Bool, Bool}})::Dictionary{UInt64, UInt64}

        dictionary = Dictionary{UInt64, UInt64}()

        nonCircularCount = UInt64(0)

        for melody_index in UInt64(0):UInt64(mss.spaceSize - 1)
            melody = matrix[:, melody_index + 1]                # + 1 because array indices in Julia are 1-based
            (isClosed, isCircular) = vector[melody_index + 1]   # + 1 because array indices in Julia are 1-based

            # println("melody_index: $melody_index, melody: $melody, isCircular: $isCircular")       # DEBUGGING
 
            # Exclude melodies which are non  C I R C U L A R (**)
            if isCircular
                # Generate the index of all other members in the melody's Equivalence Class (EC)
                minIndex = mss.spaceSize        # integer above the max possible index
                for step in 1:(mss.n - 1)
                    # println("step: $step")                                                         # DEBUGGING

                    lastInMelody = melody[mss.n]
                    # https://stackoverflow.com/questions/62444721/how-to-implement-a-decrementing-for-loop-in-julia
                    for k = mss.n : -1 : 2      
                        melody[k] = melody[k-1] # 1-step clockwise 'rotation' of the melody
                    end
                    melody[1] = lastInMelody

                    index = getMelodyIndex(mss, melody)
                    if (index < minIndex) minIndex = index end

                    # println("step: $step, melody: $melody, index: $index, minIndex: $minIndex")     # DEBUGGING

                end #   for rotation_step in 1:mss.n - 1
                
                insert!(dictionary, melody_index, minIndex) # see https://juliapackages.com/p/dictionaries

                # println("melody_index: $melody_index - minIndex: $minIndex")                        # DEBUGGING

            else    # if isCircular

                nonCircularCount += 1

            end     # if isCircular
        end     # for melody_index...

        #  vkeys = vkeys = sort(collect(keys(dictionary)))   # vector of sorted dictionary keys

        println("melodyClassesRepresentative() : found $nonCircularCount NON-CIRCULAR melodies in the sample space")

        return dictionary

        #   (**)Otherwise, repeating a melody sequentially two or more times would produce a sequence where the 
        #       variation of sound pitch (VSP) at the juncture of two consecutive instances of the melody would 
        #       NOT be an element of the melody sample space's mss.AVSPWRTPN[] array 

    end     #function melodyClassesRepresentative

end # module