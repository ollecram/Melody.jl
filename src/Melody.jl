module Melody

    export MelodySampleSpace, makeMelodySampleSpace
    export getZero, getMelodyIndex, getMelodyFromIndex, isCircular

    """
    MelodySampleSpace defines criteria for generating a melody,
        i.e. a sequence of music notes subject to constraints such 
        as the length (n) of the sequence of notes and, more critical, 
        the set of A-dmitted V-ariations (i.e. increase or decrease) of 
        the  S-ound P-itch (AVSP) of a note W-ith R-espect to the pitch 
        of the P-receding N-ote  (WRTPN), in units of 1 semi-tone. 
        This set is given as an array (AVSPWRTPN) of Int8 values 
        Typical choices for AVSPWRTPN could be:
            A)  {-5,-4,-3,-2,-1,0,1,2,3,4,5} or
            B)  {-5,-4,-3,-2,-1,  1,2,3,4,5}
        where choice B) restrict melodies to those where there can
        NOT be two or more consecutive instances of the same note. 
        Once AVSPWRTPN is given, a sequence of (n-1) of its values, 
        together with the note (pitch value) at a single place of the
        corresponding sequence, defines an entire melody of length n. 
    """
    struct MelodySampleSpace
        
        # The number of  i n t e r v a l s   in each melody.
        # Melodies in this space will therefore contain  (n + 1)   n o t e s 
        n::UInt8
    	
        # Within the whole sequence of notes that make a melody generated by this SW,
        # each number in the AVSPWRTPN array represents one element of the set of 
        # A-dmitted V-ariations (i.e. increase or decrease) of the  S-ound P-itch (AVSP)
        # of a note W-ith R-espect to the pitch of the P-receding N-ote  (WRTPN), in 
        # units of  1 semi-tone. Being AVSPWRTPN an arrey representation of a set, the
        # same value MUST NOT appear in it more than ONCE!
        AVSPWRTPN::Vector{Int8}

        # Number of distinct melodies satisfying the above two criteria
        # This number is computed as  length(AVSPWRTPN)^(n-1), a number to  
        # be compared with the largest value of a UInt64 integer: (2^64 -1)
        spaceSize::UInt64

        # (*) For the purposes of this software, any two melodies are considered the SAME melody
        #     if one can be obtained from the other by applying a uniform translation of pitch!
        #     Therefore, the number of distinct melodies is length(AVSPWRTPN)^(n-1)    

    end # struct

    """
    This builder of a MelodySampleSpace (MSS) assumes the AVSPWRTPN 
    vector to be the sequence of all integers from -m to +m with the  
    Zero optionally excluded by specifying 'allowZero = false' 
    - n::UInt8   is the length of the melody, i.e. the number of notes in it.
    - m::UInt8   is a positive integer, and we consider the set of integers in [-m, +m] 
    - allowZero::Bool   if false, we exclude zero from the above interval [-m, +m]
    """
    function makeMelodySampleSpace(n::UInt8, m::UInt8; allowZero::Bool = true) 
        if allowZero
            avspwrtpn = Int8[-Int8(m):1:Int8(m);]
            spaceSize = UInt64((2m+1)^n)
        else
            avspwrtpn = zeros(Int8, 2*m)
            avspwrtpn[  1: m] = Int8[-Int8(m):1:Int8(-1);]
            avspwrtpn[m+1:2m] = Int8[ Int8(1):1:Int8( m);]
            spaceSize = UInt64((2m)^n)
        end
        
        MelodySampleSpace(n, avspwrtpn, spaceSize)
        
    end # function

    """
    This function returns a UInt8[] array of length <n> all of whose elements are zero.
    Note that in any base <B> (e.g. 7 or 10) this function returns a representation of 
    the number 0 which is consistent with the representation of any other positive 
    number as an array of length <n> = <MelodySampleSpace.n>, where the value at index
    <k> is meant to multiply <B> elevated to the power (n-k)
    """
    function  getZero(mss::MelodySampleSpace)::Vector{UInt8}
        zeros(UInt8, mss.n)
    end

    """
    Return the UInt64 integer value in the interval [1 : mss.spaceSize] uniquely
    associated with the input Int8 array of mss.n elements 
    """
    function getMelodyIndex(mss::MelodySampleSpace, avsp::Vector{Int8})::UInt64
        # Validate avsp input argument's length
        @assert (length(avsp) == mss.n)  ArgumentError("avsp array's length ($(length(avsp))) must equal mss.n ($(mss.n))")
        
        # Validate each one of avsp's elements against mss.AVSPWRTPN
        AVSPWRTPN_length = length(mss.AVSPWRTPN)
        avsp_matching_element_index = zeros(Int8, mss.n)
        for k in 1:Int(mss.n)
            avsp_k = avsp[k]
            k_match = false
            for j in 1:AVSPWRTPN_length
                if (avsp_k == mss.AVSPWRTPN[j])
                    avsp_matching_element_index[k] = j
                    k_match = true; break
                end
            end
            @assert k_match ArgumentError("The $(k)-th melody element ($avsp_k) does NOT match any element in mss.AVSPWRTPN")
        end

        # Compute the melody index 
        awspCardinality = length(mss.AVSPWRTPN)     # Cardinality of AVSPWRTPN (as a set of unique elements)
        pow = awspCardinality^(Int(mss.n) - 1)      # Max needed pow of AVSPWRTPN's (set) cardinality
        melody_index = Int64(0)                     # We take 0 to be the lowest possible melody index 

        for k in 1:Int(mss.n)
            j = avsp_matching_element_index[k]
            melody_index += (j-1)*pow
            pow = div(pow, awspCardinality)         # Beware! 'pow /= awspCardinality' would produce a FLOAT64
        end

        return melody_index
    end

    """
    Return the melody as an Int8[] array of AVSP from a UInt64 integer value in
    the interval [1 : mss.spaceSize], to be interpreted as the melody index 
    """
    function getMelodyFromIndex(mss::MelodySampleSpace, index::UInt64)::Vector{Int8}
        # Validate input arguments
        @assert (index >= 0)             ArgumentError("index ($index) cannot be lower than 0")
        @assert (index < mss.spaceSize)  ArgumentError("index ($index) must be lower than $(mss.spaceSize)")
        
        # Derive a Vector{Int8} array with mss.n elements, each one also being an element of mss.AVSPWRTPN.
        avspCardinality = UInt64(length(mss.AVSPWRTPN)) # Cardinality of AVSPWRTPN (as a set of unique elements)
        pow    = UInt64(avspCardinality)^(Int(mss.n))   # AVSPWRTPN's cardinality power of melodies AVSP (**) 

        melody = zeros(Int8, mss.n)                     # Initialize melody with  mss.n  zeros
        windex = index                                  # Avoid messing with the input argument
        for k in 1:Int(mss.n)
            pow  = UInt64(pow / avspCardinality)        # Cardinality power associated to the k-th AVSP element 
            println("k: $k, melody[$k]: $(melody[k]), type of pow: $(typeof(pow)),  pow(k): $(pow)" )
            divisor = div(windex, pow)                  # Divisor MUST be in the range  0:length(mss.AVSPWRTPN)-1
            println("k=$k, windex=$windex, divisor=$(Int8(divisor)), pow = $(Int(pow))")
            melody[k] = mss.AVSPWRTPN[Int8(divisor)+1]  # Julia array indexing is 1-based, yet divisor can be zero!
            windex -= Int(pow * divisor)
            # pow  = UInt64(pow / avspCardinality)      # Moved to the loop's beginning, as explained below (**)
        end

        return melody
        # (**) Initializing UInt64(avspCardinality)^(Int(mss.n)), although the max power of avspCardinality that 
        # is required for representing all possible melodies is avspCardinality^(Int(mss.n) - 1). Our choice 
        # here is done just so that the pow's value can be made available with the 1ST instruction of the 
        # following for-loop over k, rather than with the LAST one (as it would otherwise be necessary).
    end

    """
	I M P O R T A N T   O B S E R V A T I O N  on  C I R C U L A R   melodies
	The chance is not zero that the sum of the n-1 AVSP's in a particular melody be zero. 
	We refer to sequences with this property as   C I R C U L A R . 
	The following scheme (where '|' is a note and 'a,b,c...' are AVSP's) should explain why 
	
	|a|b|c|_|_|_|_|_|_|_|_|_|_|_|_|_|x|y|z|a|b|c|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|x|y|z|
	 1 2 3 . . . . . . . . . . . . . . . n 1 2 3 . . . . . . . . . . . . . . . . . n
	
	Let the sum a+b+c+ ... + x+y+z be zero. But a,b,c,... represent intervals (in pitch)
	between two consecutive sounds. Thus |a| is the interval between sounds 1 and 2, etc.
	If and only if the SUM a+b+c+...+x+y+z = 0 can we assert that sound 1 and sound n are
	the  S A M E  sound. When this happens we say that a particular sequence of intervals 
    is   C I R C U L A R
	 
	This method returns true  IFF a melody with the given index is  C I R C U L A R 
	 
	"""
    function isCircular(melodyIndex::UInt64, mss::MelodySampleSpace)::Bool
        # Remind: there is one AVSP less in a melody than there are notes

        avsp = getMelodyFromIndex(melodyIndex, mss)
        sum = 0
        for k in 1:mss.n    
            sum += avsp[k]
        end

        return (sum == 0)

    end

end # module